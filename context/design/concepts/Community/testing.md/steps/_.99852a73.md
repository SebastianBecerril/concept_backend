---
timestamp: 'Thu Oct 23 2025 21:06:38 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251023_210638.e15b2189.md]]'
content_id: 99852a7390a66009d7b6fc14290db9e1bbe798c25b2be7de3c903fbd9120373b
---

# Guidelines

**Testing concepts**. Your tests should cover the basic behavior of the concept but should also include some more interesting cases. Your tests should use the Deno testing framework and should be programmatic (that is, determining in the code whether they succeeded or failed, and not requiring a human to interpret console messages). They should also print helpful messages to the console with action inputs and outputs so that a human reader can make sense of the test execution when it runs in the console. Some more details about the test cases you should include:

* **Operational principle**. A sequence of action executions that corresponds to the operational principle, representing the common expected usage of the concept. These sequence is not required to use all the actions; operational principles often do not include a deletion action, for example.
* **Interesting scenarios**. Sequences of action executions that correspond to less common cases: probing interesting corners of the functionality, undoing actions with deletions and cancellations, repeating actions with the same arguments, etc. In some of these scenarios actions may be expected to throw errors.
* **Number required**. For each concept, you should have one test sequence for the operational principle, and 3-5 additional interesting scenarios. Every action should be executed successfully in at least one of the scenarios.
* **No state setup**. Your test cases should not require any setting up of the concept state except by calling concept actions. When you are testing one action at a time, this means that you will want to order your actions carefully (for example, by the operational principle) to avoid having to set up state.
* **Saving test execution output**. Save the test execution output by copy-pasting from the console to a markdown file.

### concept Community \[User]

* **purpose**
  Group users into distinct social or organizational units and manage their membership and roles.
* **principle**
  After a user creates a community, they can invite other users to join as members and assign roles, enabling structured interaction within that unit.
* **state**
  * a set of Communities with
    * a `name` String
    * a `description` String
    * a `creationDate` DateTime
    * a `memberships` set of Memberships
  * a set of Memberships with
    * a `user` User
    * a `community` Community
    * a `role` String
    * a `joinDate` DateTime
* **actions**
  * `createCommunity(name: String, description: String, creator: User): (community: Community)`
    * **requires** `name` and `description` are non-empty, a `Community` with `name` does not exist, `creator` exists
    * **effect** creates a new `Community` with the given `name` and `description`, and adds `creator` as an `ADMIN` `Membership` to this `Community`
  * `updateCommunityDetails(community: Community, newName: String, newDescription: String, requester: User): ()`
    * **requires** `community` exists, `requester` is an `ADMIN` member of `community`
    * **effect** updates the `name` and `description` of `community`
  * `addMember(community: Community, user: User, inviter: User): ()`
    * **requires** `community` exists, `user` exists, `inviter` exists, `user` is not already a member of `community`, `inviter` is an `ADMIN` member of `community`
    * **effect** creates a `Membership` for `user` in `community` with `MEMBER` role
  * `removeMember(community: Community, user: User, requester: User): ()`
    * **requires** `community` exists, `user` is a member of `community`, (`requester` is an `ADMIN` member of `community` OR `requester` is `user`)
    * **effect** removes the `Membership` of `user` from `community`
  * `setMemberRole(membership: Membership, newRole: String, requester: User): ()`
    * **requires** `membership` exists, `newRole` is valid, `requester` is an `ADMIN` member of `membership.community`, `requester` is not attempting to demote themselves from `ADMIN` to `MEMBER` (unless there is another `ADMIN`)
    * **effect** updates `membership.role` to `newRole`
  * `deleteCommunity(community: Community, requester: User): ()`
    * **requires** `community` exists, `requester` is an `ADMIN` member of `community`
    * **effect** removes `community` and all associated `Memberships`
