---
timestamp: 'Thu Oct 23 2025 08:36:35 GMT-0400 (Eastern Daylight Time)'
content_id: 3fa168983251c544803790df75036201b6d520460a7b26f5e6670ce261b69163
---

# file: src/concepts/UserAuthentication/UserAuthenticationConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

/**
 * @concept UserAuthentication
 * @purpose Identify users and manage their access credentials.
 * @principle After a user registers with unique credentials, they can log in
 *   to prove their identity, establishing an authenticated session for further interactions.
 */
export default class UserAuthenticationConcept {
  // Declare collection prefix, use concept name
  private static readonly PREFIX = "UserAuthentication" + ".";

  /**
   * @state
   * a set of Users with
   *   a `username` String
   *   a `password` String (Note: In a real application, passwords should be hashed)
   *   a `registrationDate` DateTime
   */
  users: Collection<UserSchema>;

  /**
   * @state
   * a set of ActiveSessions with
   *   a `user` User
   *   a `sessionId` String
   *   a `creationTime` DateTime
   *   an `expiryTime` DateTime
   */
  activeSessions: Collection<ActiveSessionSchema>;

  constructor(private readonly db: Db) {
    this.users = this.db.collection(UserAuthenticationConcept.PREFIX + "users");
    this.activeSessions = this.db.collection(UserAuthenticationConcept.PREFIX + "activeSessions");

    // Ensure unique index for username
    this.users.createIndex({ username: 1 }, { unique: true })
      .catch(console.error); // Handle potential errors during index creation
    // Ensure index for expiry time for efficient cleanup
    this.activeSessions.createIndex({ expiryTime: 1 }, { expireAfterSeconds: 0 })
      .catch(console.error); // This uses MongoDB's TTL index for automatic expiry
  }

  /**
   * @action register
   * @requires `username` is unique, `password` meets strength requirements (assumed for now).
   * @effects creates a new `User` with the given `username` and a `password`
   * @param {string} username - The desired username.
   * @param {string} password - The user's password.
   * @returns {{ user: ID } | { error: string }} The ID of the new user or an error message.
   */
  async register({
    username,
    password,
  }: {
    username: string;
    password: string;
  }): Promise<{ user: ID } | { error: string }> {
    // In a real app, password would be hashed here, and strength checked.
    // For this example, we'll store it directly for simplicity.

    // Check if username already exists
    const existingUser = await this.users.findOne({ username });
    if (existingUser) {
      return { error: "Username already taken." };
    }

    // Basic password strength check (for demonstration)
    if (password.length < 6) {
      return { error: "Password must be at least 6 characters long." };
    }

    const newUserId = freshID();
    const newUser: UserSchema = {
      _id: newUserId,
      username,
      // In production, use a strong hashing algorithm like bcrypt
      password,
      registrationDate: new Date(),
    };

    try {
      await this.users.insertOne(newUser);
      return { user: newUserId };
    } catch (e) {
      console.error("Error registering user:", e);
      return { error: "Failed to register user due to a system error." };
    }
  }

  /**
   * @action login
   * @requires `username` and `password` match an existing `User`.
   * @effects creates a new `ActiveSession` for the matched `User` with a unique
   *   `sessionId` and `expiryTime`, returning the `User` and `sessionId`.
   * @param {string} username - The username to log in with.
   * @param {string} password - The password for the username.
   * @returns {{ user: ID, sessionId: ID } | { error: string }} User ID and session ID, or an error.
   */
  async login({
    username,
    password,
  }: {
    username: string;
    password: string;
  }): Promise<{ user: ID; sessionId: ID } | { error: string }> {
    // Find user by username and password (unhashed for this example)
    const user = await this.users.findOne({ username, password });

    if (!user) {
      return { error: "Invalid username or password." };
    }

    const sessionId = freshID();
    const creationTime = new Date();
    // Session expires in 1 hour (3600 seconds)
    const expiryTime = new Date(creationTime.getTime() + 60 * 60 * 1000);

    const newSession: ActiveSessionSchema = {
      _id: sessionId,
      user: user._id,
      creationTime,
      expiryTime,
    };

    try {
      await this.activeSessions.insertOne(newSession);
      return { user: user._id, sessionId };
    } catch (e) {
      console.error("Error creating session:", e);
      return { error: "Failed to create session due to a system error." };
    }
  }

  /**
   * @action logout
   * @requires `sessionId` matches an existing `ActiveSession`.
   * @effects removes the `ActiveSession`.
   * @param {ID} sessionId - The session ID to terminate.
   * @returns {Empty | { error: string }} An empty object on success, or an error message.
   */
  async logout({ sessionId }: { sessionId: ID }): Promise<Empty | { error: string }> {
    try {
      const result = await this.activeSessions.deleteOne({ _id: sessionId });
      if (result.deletedCount === 0) {
        return { error: "Session not found or already expired." };
      }
      return {};
    } catch (e) {
      console.error("Error deleting session:", e);
      return { error: "Failed to log out due to a system error." };
    }
  }

  /**
   * @action system invalidateExpiredSessions
   * @requires an `ActiveSession` exists where `currentTime` is after `expiryTime`.
   * @effects removes all `ActiveSessions` where `currentTime` is after `expiryTime`.
   * @returns {Empty} An empty object.
   */
  async invalidateExpiredSessions(): Promise<Empty> {
    // MongoDB's TTL index can handle this automatically if configured.
    // However, if we needed manual control or different logic, it would look like this:
    const currentTime = new Date();
    try {
      const result = await this.activeSessions.deleteMany({
        expiryTime: { $lte: currentTime },
      });
      // console.log(`Invalidated ${result.deletedCount} expired sessions.`);
      return {};
    } catch (e) {
      console.error("Error invalidating expired sessions:", e);
      // Even in case of error, a system action doesn't necessarily return an 'error' object.
      // It might log internally or trigger other system alerts.
      return {};
    }
  }

  /**
   * @query _isValidSession
   * Checks if a given session ID is currently active and valid.
   * @param {ID} sessionId - The session ID to check.
   * @returns {{ user: ID } | Empty} The user ID if valid, otherwise an empty object.
   */
  async _isValidSession({ sessionId }: { sessionId: ID }): Promise<{ user: ID } | Empty> {
    const session = await this.activeSessions.findOne({ _id: sessionId });
    if (session && session.expiryTime > new Date()) {
      return { user: session.user };
    }
    return {};
  }

  /**
   * @query _getUserByUsername
   * Retrieves a user's basic information by username.
   * @param {string} username - The username to query.
   * @returns {{ user: ID, registrationDate: Date } | Empty} User ID and registration date if found, otherwise empty.
   */
  async _getUserByUsername({ username }: { username: string }): Promise<{ user: ID, registrationDate: Date } | Empty> {
    const user = await this.users.findOne({ username });
    if (user) {
      return { user: user._id, registrationDate: user.registrationDate };
    }
    return {};
  }
}

// --- Internal Schemas for MongoDB Collections ---

interface UserSchema {
  _id: ID;
  username: string;
  password: string; // Stored directly for this example, hash in production!
  registrationDate: Date;
}

interface ActiveSessionSchema {
  _id: ID; // Represents sessionId
  user: ID; // References User._id
  creationTime: Date;
  expiryTime: Date;
}
```
