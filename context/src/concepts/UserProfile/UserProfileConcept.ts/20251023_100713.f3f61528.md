---
timestamp: 'Thu Oct 23 2025 10:07:13 GMT-0400 (Eastern Daylight Time)'
content_id: f3f615281b5a63bc732b3c4821bcb50d38ff6a3bea1dae354c7e6937f2d577d3
---

# file: src/concepts/UserProfile/UserProfileConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { freshID } from "@utils/database.ts";
import { Empty, ID } from "@utils/types.ts";

// Collection prefix to ensure namespace separation in MongoDB
const PREFIX = "UserProfile.";

/**
 * Represents the state for the UserProfile concept.
 * Each document in the 'profiles' collection corresponds to one user's profile.
 * - a set of Profiles with
 *   - a `user` ID
 *   - a `displayName` String
 *   - an optional `bio` String
 *   - an optional `thumbnailImageURL` String
 */
interface ProfileSchema {
  _id: ID;
  user: ID;
  displayName: string;
  bio?: string;
  thumbnailImageURL?: string;
}

/**
 * @concept UserProfile
 * @purpose Store and manage user-specific descriptive information, distinct from authentication credentials.
 */
export default class UserProfileConcept {
  public readonly profiles: Collection<ProfileSchema>;

  constructor(private readonly db: Db) {
    this.profiles = this.db.collection<ProfileSchema>(PREFIX + "profiles");
    this.profiles.createIndex({ user: 1 }, { unique: true });
  }

  /**
   * ACTION: createProfile
   * @requires `user` exists, no `ID` already exists for `user`, `displayName` is non-empty
   * @effect creates a new `ID` for `user` with the given `displayName`
   */
  async createProfile(
    { user, displayName }: { user: ID; displayName: string },
  ): Promise<{ profile: ID } | { error: string }> {
    if (!displayName || displayName.trim().length === 0) {
      return { error: "Display name cannot be empty." };
    }

    try {
      // The unique index on 'user' will prevent duplicates, but we can provide a clearer error message by checking first.
      const existingProfile = await this._getProfileByUser({ user });
      if (existingProfile) {
        return { error: "A profile for this user already exists." };
      }

      const newProfile: ProfileSchema = {
        _id: freshID() as ID,
        user,
        displayName,
      };

      await this.profiles.insertOne(newProfile);
      return { profile: newProfile._id };
    } catch (e) {
      console.error("Unexpected error in createProfile:", e);
      return { error: "An unexpected database error occurred." };
    }
  }

  /**
   * ACTION: updateDisplayName
   * @requires `profile` exists, `newDisplayName` is non-empty
   * @effect updates `profile.displayName` to `newDisplayName`
   */
  async updateDisplayName(
    { profile, newDisplayName }: { profile: ID; newDisplayName: string },
  ): Promise<Empty | { error: string }> {
    if (!newDisplayName || newDisplayName.trim().length === 0) {
      return { error: "Display name cannot be empty." };
    }
    const result = await this.profiles.updateOne({ _id: profile }, {
      $set: { displayName: newDisplayName },
    });
    if (result.matchedCount === 0) {
      return { error: "ID not found." };
    }
    return {};
  }

  /**
   * ACTION: updateBio
   * @requires `profile` exists
   * @effect updates `profile.bio` to `newBio`
   */
  async updateBio(
    { profile, newBio }: { profile: ID; newBio: string },
  ): Promise<Empty | { error: string }> {
    const result = await this.profiles.updateOne({ _id: profile }, {
      $set: { bio: newBio },
    });
    if (result.matchedCount === 0) {
      return { error: "ID not found." };
    }
    return {};
  }

  /**
   * ACTION: updateThumbnailImage
   * @requires `profile` exists
   * @effect updates `profile.thumbnailImageURL` to `newThumbnailImageURL`
   */
  async updateThumbnailImage(
    { profile, newThumbnailImageURL }: {
      profile: ID;
      newThumbnailImageURL: string;
    },
  ): Promise<Empty | { error: string }> {
    const result = await this.profiles.updateOne({ _id: profile }, {
      $set: { thumbnailImageURL: newThumbnailImageURL },
    });
    if (result.matchedCount === 0) {
      return { error: "ID not found." };
    }
    return {};
  }

  /**
   * ACTION: deleteProfile
   * @requires `profile` exists
   * @effect deletes `profile` from the set
   */
  async deleteProfile(
    { profile }: { profile: ID },
  ): Promise<Empty | { error: string }> {
    const result = await this.profiles.deleteOne({ _id: profile });
    if (result.deletedCount === 0) {
      return { error: "ID not found." };
    }
    return {};
  }

  // QUERIES

  /**
   * QUERY: Get a single profile by its unique ID.
   */
  async _getProfileById(
    { profile }: { profile: ID },
  ): Promise<ProfileSchema | null> {
    return this.profiles.findOne({ _id: profile });
  }

  /**
   * QUERY: Get a single profile by its associated user ID.
   */
  async _getProfileByUser(
    { user }: { user: ID },
  ): Promise<ProfileSchema | null> {
    return this.profiles.findOne({ user });
  }
}

```
